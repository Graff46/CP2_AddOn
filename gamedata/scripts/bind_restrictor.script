-- -*- mode: lua; encoding: windows-1251 -*-
--[[------------------------------------------------------------------------------------------------
Space restrictor binder
Чугай Александр

Примечания:
  - обновлений у рестрикторов нету, поэтому для тех, кому надо, актёр вызывает искусственно на своём обновлении
--------------------------------------------------------------------------------------------------]]
local removed_names = {
	['gar_vagon_in_restrictor'] = true,
	['bar_restrictor'] = true,
	['rostok_sniper_killer_restrictor'] = true,
	['agr_u_bloodsucker_rest'] = true
}

local updatable_binders = {}    -- биндеры, которые требуют обновлений (update)

function actor_update(delta)
  for i, v in pairs(updatable_binders) do
    v:actor_update(delta)
  end
end

function bind( obj )
	if removed_names[obj:name()] then
		local sobj=alife():object(obj:id())
		if sobj then
			alife():release(sobj,true)
			return
		end
	end

	obj:bind_object( restrictor_binder( obj ) )
end

----------------------------------------------------------------------------------------------------
class "restrictor_binder" ( object_binder )

function restrictor_binder:__init(obj, char_ini) super(obj)
  self.initialized = false
  self.loaded = false
end

function restrictor_binder:reload(section)
  object_binder.reload(self, section)
end

function restrictor_binder:reinit()
  object_binder.reinit(self)

  db.add_zone( self.object )
--  db.storage[self.object:id()] = { }

  self.st = db.storage[self.object:id()]
end

function restrictor_binder:net_spawn(data)
  if not object_binder.net_spawn( self,data ) then
    return false
  end

--  db.add_zone( self.object )

  -- Не регистрироваться на апдейты, если у объекта в customdata
  -- нет секции logic вообще.
  --[=[ ОП-2:
	Функция xr_logic.get_customdata_or_ini_file(self.object, "<customdata>") при отсутствии у рестриктора кастомдаты
	возвращает "пустую" логику: return ini_file([[scripts\dummy.ltx]]),	в которой секция logic есть.
	Поэтому в updatable_binders в варианте от ПЫСов, несмотря на их коммент выше, регистрируются на апдейты АБСОЛЮТНО ВСЕ рестрикторы. Даже те, у которых нет кастомдаты вообще.
	Поэтому условие проверки доработано на проверку строки active ~= nil и отсутствие строки cfg.
  --]=] 
  local char_ini = xr_logic.get_customdata_or_ini_file(self.object, "<customdata>")
--if char_ini:section_exist("logic") then
  if xr_logic.logic_not_empty(self.object, char_ini) then
--	get_console():execute("load ~~~ На апдейт: "..self.object:name())
    updatable_binders[self.object:id()] = self
--else
--	get_console():execute("load ~~~ Незарегистрирован на апдейт: "..self.object:name())
  end

  return true
end

function restrictor_binder:net_destroy()
  local st = db.storage[self.object:id()]
  if st.active_scheme then
    xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy")
  end

  db.del_zone( self.object )

  updatable_binders[self.object:id()] = nil

--  db.storage[self.object:id()] = nil

  object_binder.net_destroy(self)
end

-- вызывается из обновления актёра!
function restrictor_binder:actor_update(delta)
  if not self.initialized then
    self.initialized = true
    xr_logic.initialize_obj(self.object, self.st, self.loaded, db.actor, modules.stype_restrictor)
  end

  if self.st.active_section ~= nil then
    xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "update", delta)
  elseif self.object:section() == "space_restrictor" and self.object:name() == self.object:section()..self.object:id() then
	--[[ ОП-2: 
	Рестрикторы, у которых логика вышла в nil, не удаляются еще от ПЫСов и болтаются в памяти всю игру. И этот апдейт для них постоянно вызывается.
	Но теперь, согласно правке заполнения updatable_binders выше, в этой таблице есть только рестрикторы с логикой.
	И их логика вышла в nil, поэтому их смело можно было бы удалить. Но некоторые из них используются дополнительно как рестрикторы зон для неписей.
	Поэтому удаляем только обычные рестрикторы, заспавненные скриптом. У скриптового рестриктора name = секция+ид.
	А алспауновские и с уникальными секциями не удаляем ... 
	--]]
--	get_console():execute("load ~~~ Удален рестриктор: "..self.object:name())
	local se_obj = alife():object(self.object:id())
	if se_obj then alife():release(se_obj, true) end
  else
	-- ... а просто снимаем с апдейта
--	get_console():execute("load ~~~ Снят с апдейта рестриктор: "..self.object:name())
	updatable_binders[self.object:id()] = nil
  end
end

function restrictor_binder:net_save_relevant()
  return true
end

function restrictor_binder:save(packet)
  object_binder.save(self, packet)

  xr_logic.save_obj(self.object, packet)
  
end

function restrictor_binder:load(reader)
  self.loaded = true

  printf( "restrictor_binder:load" )

  object_binder.load(self, reader)

  xr_logic.load_obj(self.object, reader)
end

